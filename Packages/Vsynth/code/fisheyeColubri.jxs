<jittershader name="default">
  <description> Default Slab </description>
  <param name="tex0" type="int" default="0" />
  <param name="aperture" type="float" default="180" />
  <language name="glsl" version="1.0">
    <bind param="tex0" program="fp" />  
    <bind param="aperture" program="fp" />      
    <program name="vp" type="vertex">
<![CDATA[

varying vec2 texcoord;
varying vec2 texSize;

void main (void)

{
    gl_Position = ftransform();
    texcoord = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);
    texSize  = vec2(abs(gl_TextureMatrix[0][0][0]),abs(gl_TextureMatrix[0][1][1]));

}
]]>   
    </program>
    <program name="fp" type="fragment">
<![CDATA[

varying vec2 texcoord;
varying vec2 texSize;

uniform sampler2DRect tex0;
uniform float aperture;

const float PI = 3.1415926535;

void main(void) {    
  
  float ratio = texSize.x / texSize.y;
  
  float apertureHalf = 0.5 * aperture * (PI / 180.0);

  // This factor ajusts the coordinates in the case that
  // the aperture angle is less than 180 degrees, in which
  // case the area displayed is not the entire half-sphere.
  float maxFactor = sin(apertureHalf);

  // The st factor takes into account the situation when non-pot
  // textures are not supported, so that the maximum texture
  // coordinate to cover the entire image might not be 1.
  vec2 stFactor = vec2(1.0 / abs(texSize.x), 1.0 / abs(texSize.y)); 


vec2 pos = (2.0 * (texcoord * stFactor) - 1.);
pos.x *= ratio;

  float l = length(pos);

  if (l > 1.0) {
    gl_FragColor = vec4(0.0,0.0,0.0, 0.0);  

  } else {
    float x = maxFactor * pos.x;
    float y = maxFactor * pos.y;

    float n = length(vec2(x, y));

    float z = sqrt(1.0 - n * n);

    float r = atan(n, z) / PI;

    float phi = atan(y, x);

    float u = r * cos(phi) + 0.5;
    float v = r * sin(phi) + 0.5;

    gl_FragColor = texture2DRect(tex0, vec2(u, v) / stFactor);
  }
}
]]>
    </program>
  </language>
</jittershader>
